结构型模式关注如何将现有类或对象组织在一起形成更加强大的结构。不同不结构型模式从不同的角度组合类或对象。
类结构型模式关注类的组合，由多个类通过继承关系和实现关系，组合成一个更大的系统；
对象结构型模式关心类与对象的组合，通过关联关系，在一个类中，定义另一个类的实例对象，然后通过改对象，调用相应的方法。
根据合成复用原则，在系统中，尽量使用关联关系，代替继承关系，因此，对象结构型模式多于类结构型模式。


适配器模式/包装模式
(Adapter)
将一个类的接口转换成客户希望的另一个接口。适配器模式让那些不兼容的类可以一起工作
Convert the interface of a class into another interface client expect. Adapter lets classes work together that couldn't otherwise because of incompatible interfaces
2
4
类适配器：适配器与适配者是继承关系
对象适配器：适配器与适配者是关联关系（根据合成复用原则，对象适配器的使用频率高于类适配器）
单接口适配器（缺省适配器）：添加一个抽象类，实现adaptee接口，并为接口每个方法提供默认实现（空方法），那么抽象类的子方法可选择性重写以实现需求。


桥接模式/接口模式
(Bridge)
将抽象部分与它的实现部分解耦，使得两者都可以独立变化
Decouple an abstraction from its implementation so that the two can very independently.
3
3
解耦出来的抽象类：与解耦出的接口有关联关系，包含protected的接口定义，并包含抽象业务方法或具体业务方法
解耦出来的接口：仅需要声明需要的操作，其子类来具体不同的实现



组合模式/部分整体模式
(Composite)
组合多个对象，形成树形结构，以表示具有部分-整体关系的层次结构。组合模式让客户端可以统一地对待单个对象和组合对象
Compose objects into tree structures to represent part-whole hierarchies. Composite lets clients treat individual objects and compositions of objects uniformly.
3
4

装饰模式
(Decorator)
动态地给一个对象增加一些额外的职责。就扩展功能而言，装饰模式提供了一种比使用子类更加灵活的替代方案
3
3

外观模式
(Facade)
为子系统中的一组接口提供一个统一的入口。外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用
1
5

享元模式
(Flyweight)
运用共享技术有效地支持大量细粒度对象的复用
4
1

代理模式
(Proxy)
给某一个对象提供一个代理或占位符，并由代理对象来控制对原对象的访问
3
4